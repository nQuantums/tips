#pragma once
#include <Windows.h>
#include <iostream>
#include <string>
#include <vector>
#include "../../Junk/Thread.h"
#include "../CancelablePipe.h"

//! パイプによるサーバー
class PipeServer {
public:
	PipeServer();
	~PipeServer();
	bool Start(const wchar_t* pszPipeName, DWORD sendBufferSize = 4096, DWORD recvBufferSize = 4096, DWORD defaultTimeout = 1000);
	void Stop();

protected:
	class ClientContext {
	public:
		ClientContext(PipeServer* pOwner, const CancelablePipe& pipe) {
			m_pOwner = pOwner;
			m_Pipe = pipe;
			m_Thread.Start(&ThreadStart, this);
		}
		~ClientContext() {
			m_Pipe.Destroy();
		}

		void Stop(bool wait) {
		}

	protected:
		static intptr_t ThreadStart(void* pObj);
		void ThreadProc();

	protected:
		PipeServer* m_pOwner;
		CancelablePipe m_Pipe;
		jk::Thread m_Thread;
	};

protected:
	static intptr_t ThreadStart(void* pObj); //!< 接続受付スレッド開始アドレス
	void ThreadProc(); //!< 接続受付スレッド処理
	void AddClient(ClientContext* pClient); //!< 指定クライアントを管理下へ追加する
	bool RemoveClient(ClientContext* pClient, bool wait = false); //!< 指定クライアントを管理下から除外する

protected:
	std::wstring m_PipeName; //!< 受付パイプ名
	volatile bool m_RequestStop; //!< サーバー停止要求フラグ
	jk::Event m_RequestStopEvent; //!< サーバー停止要求イベント
	jk::Thread m_AcceptanceThread; //!< 接続受付処理スレッド
	DWORD m_SendBufferSize; //!< パイプ送信バッファサイズ
	DWORD m_RecvBufferSize; //!< パイプ受信バッファサイズ
	DWORD m_DefaultTimeout; //!< パイプ既定タイムアウト(ms)

	std::vector<ClientContext*> m_Clients; //!< クライアント処理配列
	jk::CriticalSection m_ClientsCs; //!< m_Clients アクセス排他処理用
};

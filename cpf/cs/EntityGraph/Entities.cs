using System;
using System.Linq;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace EntityGraph {
	[Flags]
	public enum EntityFlags {
		/// <summary>
		/// フィルタリングされたかどうか
		/// </summary>
		IsFiltered = 1 << 0,

		/// <summary>
		/// 削除され最初から存在しないものとして扱われる
		/// </summary>
		IsDeleted = 1 << 1,

		/// <summary>
		/// 非表示にされ関連が親に引き継がれる
		/// </summary>
		IsHidden = 1 << 2,
	}

	/// <summary>
	/// グラフの要素となる
	/// </summary>
	public class Entity {
		public EntityFlags Flags;

		/// <summary>
		/// 種類名
		/// </summary>
		public readonly string KindName;

		/// <summary>
		/// 表示名
		/// </summary>
		public string Name;

		/// <summary>
		/// 親<see cref="Entity"/>
		/// </summary>
		public Entity Parent;

		/// <summary>
		/// ノードとしてグラフ描画される際の形状名
		/// </summary>
		public string DotShape;

		/// <summary>
		/// 形状描画の色
		/// </summary>
		public string DotColor;

		/// <summary>
		/// フォント描画の色
		/// </summary>
		public string DotFontColor;

		/// <summary>
		/// ノードとしてグラフ描画される際の属性
		/// </summary>
		public virtual string DotNodeAttribute {
			get {
				var sb = new StringBuilder();
				sb.Append("[");
				sb.Append("label=\"" + this.Name + "\"");
				if (this.DotShape != null) {
					sb.Append(" shape=" + this.DotShape + "");
				}
				if (this.DotColor != null) {
					sb.Append(" color=\"" + this.DotColor + "\"");
				}
				if (this.DotFontColor != null) {
					sb.Append(" fontcolor=\"" + this.DotFontColor + "\"");
				}
				sb.Append("]");
				return sb.ToString();
			}
		}

		/// <summary>
		/// コンストラクタ、種類名と表示名を指定して初期化する
		/// </summary>
		/// <param name="kindName">種類名</param>
		/// <param name="entityName">表示名</param>
		/// <remarks><see cref="Entity"/>型のフィールドが存在した場合自動的にインスタンスを生成し名称としてフィールドを使うように初期化される。</remarks>
		public Entity(string kindName, string entityName = null) {
			this.KindName = kindName;
			this.Name = entityName;

			foreach (var f in GetEntityFields()) {
				var ft = f.FieldType;
				var e = f.GetValue(this) as Entity;
				if (e == null) {
					if (ft.GetConstructor(new Type[0]) != null) {
						e = Activator.CreateInstance(ft, new object[0]) as Entity;
					} else {
						throw new ApplicationException(ft + " のコンストラクタが未対応の形式です。");
					}
					f.SetValue(this, e);
				}
				e.Parent = this;
				if (e.Name == null) {
					e.Name = f.Name;
				}
			}
		}

		public override string ToString() {
			return this.Name;
		}

		/// <summary>
		/// <see cref="Entity"/>型のフィールド一覧の取得
		/// </summary>
		public IEnumerable<FieldInfo> GetEntityFields() {
			foreach (var f in this.GetType().GetFields()) {
				if (f.FieldType.IsSubclassOf(typeof(Entity))) {
					yield return f;
				}
			}
		}

		/// <summary>
		/// 直接の子となる<see cref="Entity"/>一覧の取得
		/// </summary>
		public virtual IEnumerable<Entity> GetChild() {
			return GetEntityFields().Select(f => f.GetValue(this)).Select(e => e as Entity);
		}

		/// <summary>
		/// 直接の子と子孫となる<see cref="Entity"/>一覧の取得
		/// </summary>
		public virtual IEnumerable<Entity> GetChildAndDescendants() {
			foreach (var e in this.GetChild()) {
				yield return e;
				foreach (var e2 in e.GetChildAndDescendants()) {
					yield return e;
				}
			}
		}
	}

	/// <summary>
	/// ２つの<see cref="Entity"/>が関連していることを示す
	/// </summary>
	public class Flow {
		/// <summary>
		/// 最初の<see cref="Entiy"/>
		/// </summary>
		public Entity E1;

		/// <summary>
		/// 次の<see cref="Entiy"/>
		/// </summary>
		public Entity E2;

		public Flow(Entity from, Entity to) {
			this.E1 = from;
			this.E2 = to;
		}

		public bool IsSameDir(Flow relation) {
			return this.E1 == relation.E1 && this.E2 == relation.E2;
		}

		public Entity GetPair(Entity entity) {
			if (this.E1 == entity) {
				return this.E2;
			} else if (this.E2 == entity) {
				return this.E1;
			} else {
				return null;
			}
		}

		public override int GetHashCode() {
			return this.E1.GetHashCode() ^ this.E2.GetHashCode();
		}

		public override bool Equals(object obj) {
			var c = obj as Flow;
			if (!(c is null)) {
				return this == c;
			}
			return base.Equals(obj);
		}

		public static bool operator ==(Flow l, Flow r) {
			if (l.E1 == r.E1 && l.E2 == r.E2) {
				return true;
			}
			if (l.E1 == r.E2 && l.E2 == r.E1) {
				return true;
			}
			return false;
		}
		public static bool operator !=(Flow l, Flow r) {
			return !(l == r);
		}
	}

	/// <summary>
	/// <see cref="Flow"/>の関連の方向
	/// </summary>
	[Flags]
	public enum FlowDirection {
		Unknown,
		Forward = 1,
		Backward = 2,
		Both = 3,
	}

	[Flags]
	public enum FlowAtrFlags {
		/// <summary>
		/// 削除され最初から存在しないものとして扱われる
		/// </summary>
		IsDeleted = 1 << 0,

		/// <summary>
		/// 非表示にされ関連が親<
		/// </summary>
		IsHidden = 1 << 1,
		AutoGenerated = 1 << 2,
	}

	/// <summary>
	/// <see cref="Flow"/>に付随する属性
	/// </summary>
	public class FlowAtr {
		public Flow Flow;
		public FlowDirection Direction;

		public FlowAtr(Flow relation) {
			this.Flow = relation;
		}
	}

	public class FlowBuffer {
		public Dictionary<Flow, FlowAtr> Flows = new Dictionary<Flow, FlowAtr>();

		public FlowBuffer() {
		}

		public FlowBuffer(Dictionary<Flow, FlowAtr> flowsToAdd) {
			var flows = this.Flows;
			foreach (var kvp in flowsToAdd) {
				flows[kvp.Key] = kvp.Value;
			}
		}

		public Flow Flow(Entity from, Entity to) {
			var flow = new Flow(from, to);

			FlowAtr ra;
			if (!this.Flows.TryGetValue(flow, out ra)) {
				this.Flows[flow] = ra = new FlowAtr(flow);
			}

			if (flow.IsSameDir(ra.Flow)) {
				ra.Direction |= FlowDirection.Forward;
			} else {
				ra.Direction |= FlowDirection.Backward;
			}

			return flow;
		}

		public void Flow(Entity e1, Entity e2, Entity e3, params Entity[] entities) {
			this.Flow(e1, e2);
			this.Flow(e2, e3);
			var last = e3;
			foreach (var e in entities) {
				this.Flow(last, e);
				last = e;
			}
		}

		public Dictionary<Entity, HashSet<Flow>> GetEntities() {
			var entities = new Dictionary<Entity, HashSet<Flow>>();
			foreach (var kvp in this.Flows) {
				var flow = kvp.Key;
				var e1 = flow.E1;
				var e2 = flow.E2;

				HashSet<Flow> f;
				if (!entities.TryGetValue(e1, out f)) {
					entities[e1] = f = new HashSet<Flow>();
				}
				f.Add(flow);
				if (!entities.TryGetValue(e2, out f)) {
					entities[e2] = f = new HashSet<Flow>();
				}
				f.Add(flow);
			}
			return entities;
		}
	}


	public class GraphBuilder {
		public FlowBuffer FlowBuffer;

		public GraphBuilder(Dictionary<Flow, FlowAtr> flowsToAdd) {
			this.FlowBuffer = new FlowBuffer(flowsToAdd);
		}

		public Dictionary<Entity, HashSet<Flow>> Filter(Action<Entity> filter) {
			var fb = this.FlowBuffer;
			var flows = fb.Flows;

			for (; ; ) {
				// フィルタリングを行い要求される抽象度の関連性のみ残す
				var entities = fb.GetEntities();
				var filtered = false;
				foreach (var kvp in entities) {
					var e = kvp.Key;
					if ((e.Flags & EntityFlags.IsFiltered) != 0) {
						continue;
					}

					// フィルタリングにてフラグをセットする
					filter(e);
					e.Flags |= EntityFlags.IsFiltered;
					filtered = true;

					// セットされたフラグに応じて関連性の削除または切り替えを行う
					var flags = e.Flags;
					if ((flags & (EntityFlags.IsDeleted | EntityFlags.IsHidden)) != 0) {
						var p = e.Parent;
						var switchToParent = (flags & EntityFlags.IsHidden) != 0 && p != null;
						foreach (var flow in kvp.Value) {
							flows.Remove(flow);
							if (switchToParent) {
								fb.Flow(p, flow.GetPair(p));
							}
						}
					}
				}
				if (!filtered) {
					return entities;
				}
			}
		}
	}

	public class Graph {
		public FlowBuffer FlowBuffer = new FlowBuffer();
		public List<Task> Tasks = new List<Task>();

		public Task Task(string name) {
			var t = new Task { Name = name, FlowBuffer = this.FlowBuffer };
			this.Tasks.Add(t);
			return t;
		}

		public string GetDotCode(Action<Entity> filter = null) {
			var sb = new StringBuilder();

			sb.AppendLine(@"digraph {
	node [color=""#5050e5"" fontcolor=""#5050e5""]
	edge [fontsize=11 color=gray50 fontcolor=gray50]
");

			// 必要に応じてフィルタリングを行い、関連性を持つ Entity 一覧を取得する
			var gb = new GraphBuilder(this.FlowBuffer.Flows);
			var entities = filter != null ? gb.Filter(filter) : gb.FlowBuffer.GetEntities();

			// 直接関連性を持つものが node となり、その親が subgraph となる
			var entityToNode = new Dictionary<Entity, string>();
			Action<Entity> addNode = e => {
				string node;
				if (!entityToNode.TryGetValue(e, out node)) {
					entityToNode[e] = "node" + (entityToNode.Count + 1);
				}
			};
			foreach (var e in entities.Keys) {
				addNode(e);
			}

			// 上記の Entity でとりあえずノード生成
			foreach (var e in entityToNode) {
				sb.AppendLine(e.Value + " " + e.Key.DotNodeAttribute);
			}

			// 親子関係構築
			var parentRelationship = new Dictionary<Entity, List<Entity>>();
			foreach (var e in entities.Keys) {
				var p = e.Parent;
				if (p != null) {
					List<Entity> children;
					if (!parentRelationship.TryGetValue(p, out children)) {
						parentRelationship[p] = children = new List<Entity>();
					}
					children.Add(e);
				}
			}

			// subgraph を生成
			Action<Entity> subgraph = null;
			var subgraphCount = 0;
			subgraph = e => {
				List<Entity> children;
				if (parentRelationship.TryGetValue(e, out children)) {
					sb.AppendLine("subgraph cluster" + subgraphCount + "{");
					sb.AppendLine("label=\"" + e.Name + "\"");
					subgraphCount++;
					foreach (var c in children) {
						if (entityToNode.ContainsKey(c)) {
							sb.AppendLine(entityToNode[c]);
						} else {
							subgraph(c);
						}
					}
					sb.AppendLine("}");
				}
			};
			foreach (var e in parentRelationship.Keys) {
				var p = e.Parent;
				if (p == null || p.KindName == "root") {
					subgraph(e);
				}
			}

			// ノード間の関連生成
			foreach (var kvp in gb.FlowBuffer.Flows) {
				var flow = kvp.Key;
				var atr = kvp.Value;
				var n1 = entityToNode[flow.E1];
				var n2 = entityToNode[flow.E2];

				switch (atr.Direction) {
					case FlowDirection.Forward:
						sb.AppendLine(n1 + " -> " + n2);
						break;
					case FlowDirection.Backward:
						sb.AppendLine(n2 + " -> " + n1);
						break;
					case FlowDirection.Both:
						sb.AppendLine(n1 + " -> " + n2);
						sb.AppendLine(n2 + " -> " + n1);
						break;
				}
			}

			sb.AppendLine("}");

			return sb.ToString();
		}
	}

	public class Task : Entity {
		public FlowBuffer FlowBuffer;

		public Task() : base("Task") {
		}

		public Flow Flow(Entity from, Entity to) {
			return this.FlowBuffer.Flow(from, to);
		}

		public void Flow(Entity e1, Entity e2, Entity e3, params Entity[] entities) {
			this.FlowBuffer.Flow(e1, e2, e3, entities);
		}
	}

	public class Man : Entity {
		public Man() : base("人") {
			this.DotShape = "star";
		}
	}

	public class WebSite : Entity {
		public string Url;

		public WebSite(string url) : base("WebSite") {
			this.Url = url;
			this.DotShape = "egg";
			this.DotColor = "#40b9e5";
			this.DotFontColor = "#40b9e5";
		}
	}

	public class PC : Entity {
		public PC() : base("PC") {
		}
	}

	public class App : Entity {
		public App() : base("App") {
			this.DotShape = "doubleoctagon";
			this.DotColor = "#ff7040";
			this.DotFontColor = "#ff7040";
		}
	}

	public class Data : Entity {
		public Data(string kindName, string entityName = null) : base(kindName, entityName) {
			this.DotShape = "note";
			this.DotColor = "#10a559";
			this.DotFontColor = "#10a559";
		}
	}

	public class DataFile : Data {
		public DataFile() : base("DataFile") {
		}
	}

	public class Db : Data {
		public Db() : base("DataBase") {
			this.DotShape = "box3d";
		}
	}

	public class Tbl : Entity {
		public Tbl() : base("Table") {
		}
	}

	public class Csv : Data {
		public Csv() : base("Csv") {
		}
	}

	public class Zip : Data {
		public Zip() : base("Zip") {
		}
	}

	public class Col : Entity {
		public Type ValueType;
		public bool IsPrimaryKey;

		public Col() : base("Column") {
		}
	}

	public class Col<T> : Col {
		public Col() : base() {
			this.ValueType = typeof(T);
		}
	}

	public class ColP<T> : Col<T> {
		public ColP() : base() {
			this.IsPrimaryKey = true;
		}
	}
}

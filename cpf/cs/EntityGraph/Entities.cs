using System;
using System.Linq;
using System.Collections.Generic;
using System.Reflection;
using System.Text;

namespace EntityGraph {
	[Flags]
	public enum EntityFlags {
		/// <summary>
		/// フィルタリングされたかどうか
		/// </summary>
		IsFiltered = 1 << 0,

		/// <summary>
		/// 削除され最初から存在しないものとして扱われる
		/// </summary>
		IsDeleted = 1 << 1,

		/// <summary>
		/// 非表示にされ関連が親に引き継がれる
		/// </summary>
		IsHidden = 1 << 2,
	}

	/// <summary>
	/// グラフの要素となる
	/// </summary>
	public class Entity {
		public EntityFlags Flags;

		/// <summary>
		/// 種類名
		/// </summary>
		public readonly string KindName;

		/// <summary>
		/// 表示名
		/// </summary>
		public string Name;

		/// <summary>
		/// 親<see cref="Entity"/>
		/// </summary>
		public Entity Parent;

		/// <summary>
		/// ノードとしてグラフ描画される際の形状名
		/// </summary>
		public string DotShape;

		/// <summary>
		/// 形状描画の色
		/// </summary>
		public string DotColor;

		/// <summary>
		/// フォント描画の色
		/// </summary>
		public string DotFontColor;

		/// <summary>
		/// ノードとしてグラフ描画される際の属性
		/// </summary>
		public virtual string DotNodeAttribute {
			get {
				var sb = new StringBuilder();
				sb.Append("[");
				sb.Append("label=\"" + this.Name + "\"");
				if (this.DotShape != null) {
					sb.Append(" shape=" + this.DotShape + "");
				}
				if (this.DotColor != null) {
					sb.Append(" color=\"" + this.DotColor + "\"");
				}
				if (this.DotFontColor != null) {
					sb.Append(" fontcolor=\"" + this.DotFontColor + "\"");
				}
				sb.Append("]");
				return sb.ToString();
			}
		}

		/// <summary>
		/// コンストラクタ、種類名と表示名を指定して初期化する
		/// </summary>
		/// <param name="kindName">種類名</param>
		/// <param name="entityName">表示名</param>
		/// <remarks><see cref="Entity"/>型のフィールドが存在した場合自動的にインスタンスを生成し名称としてフィールドを使うように初期化される。</remarks>
		public Entity(string kindName, string entityName = null) {
			this.KindName = kindName;
			this.Name = entityName;

			foreach (var f in GetEntityFields()) {
				var ft = f.FieldType;
				var e = f.GetValue(this) as Entity;
				if (e == null) {
					if (ft.GetConstructor(new Type[0]) != null) {
						e = Activator.CreateInstance(ft, new object[0]) as Entity;
					} else {
						throw new ApplicationException(ft + " のコンストラクタが未対応の形式です。");
					}
					f.SetValue(this, e);
				}
				e.Parent = this;
				if (e.Name == null) {
					e.Name = f.Name;
				}
			}
		}

		public override string ToString() {
			return this.Name;
		}

		/// <summary>
		/// <see cref="Entity"/>型のフィールド一覧の取得
		/// </summary>
		public IEnumerable<FieldInfo> GetEntityFields() {
			foreach (var f in this.GetType().GetFields()) {
				if (f.FieldType.IsSubclassOf(typeof(Entity))) {
					yield return f;
				}
			}
		}

		/// <summary>
		/// 直接の子となる<see cref="Entity"/>一覧の取得
		/// </summary>
		public virtual IEnumerable<Entity> GetChild() {
			return GetEntityFields().Select(f => f.GetValue(this)).Select(e => e as Entity);
		}

		/// <summary>
		/// 直接の子と子孫となる<see cref="Entity"/>一覧の取得
		/// </summary>
		public virtual IEnumerable<Entity> GetChildAndDescendants() {
			foreach (var e in this.GetChild()) {
				yield return e;
				foreach (var e2 in e.GetChildAndDescendants()) {
					yield return e;
				}
			}
		}
	}

	/// <summary>
	/// ２つの<see cref="Entity"/>が関連していることを示す
	/// </summary>
	public class Flow {
		/// <summary>
		/// 最初の<see cref="Entiy"/>
		/// </summary>
		public Entity E1;

		/// <summary>
		/// 次の<see cref="Entiy"/>
		/// </summary>
		public Entity E2;

		public Flow(Entity from, Entity to) {
			this.E1 = from;
			this.E2 = to;
		}

		public bool IsSameDir(Flow relation) {
			return this.E1 == relation.E1 && this.E2 == relation.E2;
		}

		public override int GetHashCode() {
			return this.E1.GetHashCode() ^ this.E2.GetHashCode();
		}

		public override bool Equals(object obj) {
			var c = obj as Flow;
			if (!(c is null)) {
				return this == c;
			}
			return base.Equals(obj);
		}

		public static bool operator ==(Flow l, Flow r) {
			if (l.E1 == r.E1 && l.E2 == r.E2) {
				return true;
			}
			if (l.E1 == r.E2 && l.E2 == r.E1) {
				return true;
			}
			return false;
		}
		public static bool operator !=(Flow l, Flow r) {
			return !(l == r);
		}
	}

	/// <summary>
	/// <see cref="Flow"/>の関連の方向
	/// </summary>
	[Flags]
	public enum FlowDirection {
		Unknown,
		Forward = 1,
		Backward = 2,
		Both = 3,
	}

	[Flags]
	public enum FlowAtrFlags {
		/// <summary>
		/// 削除され最初から存在しないものとして扱われる
		/// </summary>
		IsDeleted = 1 << 0,

		/// <summary>
		/// 非表示にされ関連が親<
		/// </summary>
		IsHidden = 1 << 1,
		AutoGenerated = 1 << 2,
	}

	/// <summary>
	/// <see cref="Flow"/>に付随する属性
	/// </summary>
	public class FlowAtr {
		public Flow Flow;
		public FlowDirection Direction;

		public FlowAtr(Flow relation) {
			this.Flow = relation;
		}
	}

	public class GraphBuilder {
		public Dictionary<Flow, FlowAtr> Flows = new Dictionary<Flow, FlowAtr>();
		public Dictionary<Entity, HashSet<Flow>> Entities = new Dictionary<Entity, HashSet<Flow>>();

		public GraphBuilder(Dictionary<Flow, FlowAtr> flowsToAdd) {
			var flows = this.Flows;
			var entities = this.Entities;

			foreach (var kvp in flowsToAdd) {
				flows[kvp.Key] = kvp.Value;
			}
			foreach (var kvp in flowsToAdd) {
				var flow = kvp.Key;
				var e1 = flow.E1;
				var e2 = flow.E2;

				HashSet<Flow> f;
				if (!entities.TryGetValue(e1, out f)) {
					entities[e1] = f = new HashSet<Flow>();
				}
				f.Add(flow);
				if (!entities.TryGetValue(e2, out f)) {
					entities[e2] = f = new HashSet<Flow>();
				}
				f.Add(flow);
			}
		}

		public void Filter(Action<Entity> filter) {
			var flows = this.Flows;
			var entities = this.Entities;

			// フィルタリングを行いフラグをセットする
			foreach (var kvp in entities) {
				var e = kvp.Key;
				filter(e);
				if (e.Parent is null && (e.Flags & EntityFlags.IsHidden) != 0) {
					e.Flags |= EntityFlags.IsDeleted;
				}
				e.Flags |= EntityFlags.IsFiltered;
			}

			// 削除フラグがセットされた Entity を取り除き関連する Flow を削除する
			var deletedEntities = entities.Where(kvp => (kvp.Key.Flags & EntityFlags.IsDeleted) != 0).ToArray();
			foreach (var kvp in deletedEntities) {
				var e = kvp.Key;
				entities.Remove(e);
				foreach (var flow in kvp.Value) {
					flows.Remove(flow);
				}
			}

			// 非表示フラグがセットされた Entity から Flow を取得し親に繋ぎなおす
			foreach (var kvp in entities) {
				var e = kvp.Key;
				var p = e.Parent;
				foreach (var flow in kvp.Value) {
					flows.Remove(flow);

				}
			}
		}
	}

	public class Graph {
		public Dictionary<Flow, FlowAtr> Flows = new Dictionary<Flow, FlowAtr>();
		public List<Task> Tasks = new List<Task>();

		public Task Task(string name) {
			var t = new Task { Name = name, GlobalFlows = this.Flows };
			this.Tasks.Add(t);
			return t;
		}

		public string GetDotCode(Action<Entity> filter) {
			var sb = new StringBuilder();

			sb.AppendLine(@"digraph {
	node [color=""#5050e5"" fontcolor=""#5050e5""]
	edge [fontsize=11 color=gray50 fontcolor=gray50]
");

			var gb = new GraphBuilder(this.Flows);

			var allFlows = new Dictionary<Flow, FlowAtr>();
			var allEntities = new Dictionary<Entity, HashSet<Flow>>();

			foreach (var kvp in this.Flows) {
				allFlows[kvp.Key] = kvp.Value;
			}

			// 全ての Flow 情報から全ての Entity を取得する
			foreach (var kvp in this.Flows) {
				var flow = kvp.Key;
				var e1 = flow.E1;
				var e2 = flow.E2;

				HashSet<Flow> flows;
				if (!allEntities.TryGetValue(e1, out flows)) {
					allEntities[e1] = flows = new HashSet<Flow>();
				}
				flows.Add(flow);

				if (!allEntities.TryGetValue(e2, out flows)) {
					allEntities[e2] = flows = new HashSet<Flow>();
				}
				flows.Add(flow);
			}

			// フィルタリングを行いフラグをセットする
			foreach (var kvp in allEntities) {
				var e = kvp.Key;
				filter(e);
				if (e.Parent is null && (e.Flags & EntityFlags.IsHidden) != 0) {
					e.Flags |= EntityFlags.IsDeleted;
				}
				e.Flags |= EntityFlags.IsFiltered;
			}

			// フィルタリングを行い消えた場合は親に繋ぎなおす
			foreach (var kvp in allEntities) {
				var e = kvp.Key;
				if ((e.Flags & EntityFlags.IsDeleted) != 0) {
					foreach (var flow in kvp.Value) {
						allFlows.Remove(flow);
					}
				}
				if ((e.Flags & EntityFlags.IsHidden) != 0) {
					e.Parent
					foreach (var flow in kvp.Value) {
						allFlows.Remove(flow);
					}
				}
			}



			// TODO: Entity の子がフィルタリングされたら代わりに親 Entity に Flow を結ぶ
			// TODO: Entity がノードになるかサブグラフになるか判定
			// TODO: 親子関係から subgraph 生成


			// Flow で結ばれている Entity を取得
			var entityToNode = new Dictionary<Entity, string>();
			Action<Entity> addNode = e => {
				string node;
				if (!entityToNode.TryGetValue(e, out node)) {
					entityToNode[e] = "node" + (entityToNode.Count + 1);
				}
			};
			foreach (var ratr in this.Flows.Values) {
				addNode(ratr.Flow.E1);
				addNode(ratr.Flow.E2);
			}

			// 上記の Entity でとりあえずノード生成
			foreach (var e in entityToNode) {
				sb.AppendLine(e.Value + " " + e.Key.DotNodeAttribute);
			}

			// ノード間の関連生成
			foreach (var kvp in this.Flows) {
				var flow = kvp.Key;
				var atr = kvp.Value;
				var n1 = entityToNode[flow.E1];
				var n2 = entityToNode[flow.E2];

				switch (atr.Direction) {
				case FlowDirection.Forward:
					sb.AppendLine(n1 + " -> " + n2);
					break;
				case FlowDirection.Backward:
					sb.AppendLine(n2 + " -> " + n1);
					break;
				case FlowDirection.Both:
					sb.AppendLine(n1 + " -> " + n2);
					sb.AppendLine(n2 + " -> " + n1);
					break;
				}
			}

			//// タスク毎にサブグラフ作成してタスク内のフローをグラフ化
			//var taskIndex = 0;
			//foreach (var t in this.Tasks) {
			//	sb.AppendLine("subgraph cluster" + taskIndex + "{");
			//	sb.AppendLine("label=\"" + t.Name + "\"");

			//	foreach (var flow in t.LocalFlows) {
			//		var atr = this.Flows[flow];
			//		var n1 = entityToNode[flow.E1];
			//		var n2 = entityToNode[flow.E2];

			//		switch (atr.Direction) {
			//		case FlowDirection.Forward:
			//			sb.AppendLine(n1 + " -> " + n2);
			//			break;
			//		case FlowDirection.Backward:
			//			sb.AppendLine(n2 + " -> " + n1);
			//			break;
			//		case FlowDirection.Both:
			//			sb.AppendLine(n1 + " -> " + n2);
			//			sb.AppendLine(n2 + " -> " + n1);
			//			break;
			//		}
			//	}

			//	sb.AppendLine("}");

			//	taskIndex++;
			//}

			sb.AppendLine("}");

			return sb.ToString();
		}
	}

	public class FlowBuffer {
		public Dictionary<Flow, FlowAtr> Flows = new Dictionary<Flow, FlowAtr>();

		public Flow Flow(Entity from, Entity to) {
			var flow = new Flow(from, to);

			FlowAtr ra;
			if (!this.Flows.TryGetValue(flow, out ra)) {
				this.Flows[flow] = ra = new FlowAtr(flow);
			}

			if (flow.IsSameDir(ra.Flow)) {
				ra.Direction |= FlowDirection.Forward;
			} else {
				ra.Direction |= FlowDirection.Backward;
			}

			this.Flows.Add(flow);

			return flow;
		}

		public void Flow(Entity e1, Entity e2, Entity e3, params Entity[] entities) {
			this.Flow(e1, e2);
			this.Flow(e2, e3);
			var last = e3;
			foreach (var e in entities) {
				this.Flow(last, e);
				last = e;
			}
		}
	}

	public class Task : Entity {
		public Dictionary<Flow, FlowAtr> GlobalFlows;
		public HashSet<Flow> LocalFlows = new HashSet<Flow>();

		public Task() : base("Task") {
		}

		public Flow Flow(Entity from, Entity to) {
			var flow = new Flow(from, to);

			FlowAtr ra;
			if (!this.GlobalFlows.TryGetValue(flow, out ra)) {
				this.GlobalFlows[flow] = ra = new FlowAtr(flow);
			}

			if (flow.IsSameDir(ra.Flow)) {
				ra.Direction |= FlowDirection.Forward;
			} else {
				ra.Direction |= FlowDirection.Backward;
			}

			this.LocalFlows.Add(flow);

			return flow;
		}

		public void Flow(Entity e1, Entity e2, Entity e3, params Entity[] entities) {
			this.Flow(e1, e2);
			this.Flow(e2, e3);
			var last = e3;
			foreach (var e in entities) {
				this.Flow(last, e);
				last = e;
			}
		}
	}

	public class Man : Entity {
		public Man() : base("人") {
			this.DotShape = "star";
		}
	}

	public class WebSite : Entity {
		public string Url;

		public WebSite(string url) : base("WebSite") {
			this.Url = url;
			this.DotShape = "egg";
			this.DotColor = "#40b9e5";
			this.DotFontColor = "#40b9e5";
		}
	}

	public class PC : Entity {
		public PC() : base("PC") {
		}
	}

	public class App : Entity {
		public App() : base("App") {
			this.DotShape = "doubleoctagon";
			this.DotColor = "#ff7040";
			this.DotFontColor = "#ff7040";
		}
	}

	public class Data : Entity {
		public Data(string kindName, string entityName = null) : base(kindName, entityName) {
			this.DotShape = "note";
			this.DotColor = "#10a559";
			this.DotFontColor = "#10a559";
		}
	}

	public class DataFile : Data {
		public DataFile() : base("DataFile") {
		}
	}

	public class Db : Data {
		public Db() : base("DataBase") {
			this.DotShape = "box3d";
		}
	}

	public class Tbl : Entity {
		public Tbl() : base("Table") {
		}
	}

	public class Csv : Data {
		public Csv() : base("Csv") {
		}
	}

	public class Zip : Data {
		public Zip() : base("Zip") {
		}
	}

	public class Col : Entity {
		public Type ValueType;
		public bool IsPrimaryKey;

		public Col() : base("Column") {
		}
	}

	public class Col<T> : Col {
		public Col() : base() {
			this.ValueType = typeof(T);
		}
	}

	public class ColP<T> : Col<T> {
		public ColP() : base() {
			this.IsPrimaryKey = true;
		}
	}
}
